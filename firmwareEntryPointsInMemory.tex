\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{epsfig,endnotes,natbib}
\begin{document}

\title{\Large \bf Firmware Entry Points in Memory}
\author{
    {\rm Mahmoud Dolah}\\
    NYU Tandon School of Engineering
    \and
    {\rm Rafael De Los Santos}\\
    NYU Tandon School of Engineering
}

\date{}

\maketitle

\thispagestyle{empty}

\subsection*{Abstract}
Finding the entry points of firmware in memory is a problem that is featured prominently in many embedded systems. It is hard to find out because the method for it is not standardized and, since firmware works under the operating system, it does not follow the same rules that the OS uses. In this paper, we present an approach for automating the process of finding the entry point of firmware in memory in a file called basefind.py, which was created by Michael Coppola. We test his script against openwrt binaries. By analyzing the contents of a firmware binary, particularly the amount of strings that are referenced by each pointer, we can create a list of potential base addresses.  
TO DO: EVALUATION AND TAKEAWAY

\section{Introduction}
Unlike other areas of modern consumer computing, embeded systems suffer from a glaring lack of standardization. When shopping for a home pc or smartphone, for example, one could be relatively confident that most of the devices presented to them share similarities in hardware or software implementation. An analysis of any of these devices may provide the consumer with an intuition about other devices in their category. The same, unfortunatly, could not be said for a device running an embeded system or system on a chip. Because of the variety in software and especially hardware implementation techniques, an analysis of, say, a router, fitness tracker, or bluetooth dongle, will often yield little useful information for any kind of large scale study. Whats worse, the analysis techniques and tools used for any particular embeded system often cannot be carried over to another, forcing the analyst to redo, usually from scratch, their work.

When conducting an analysis of a firmware image, we often start with trying to find the base address of the binary. Because no tools (or even methods) exist that apply to a wide range of firmware binaries, and considering it is quite possible that information on the architecture of the device is sparse or poorly documented, researches often have to rely on manual analysis. This usually includes disassembly in some commercial tool (perhaps IDA Pro), followed by a manual analysis of the disasembly for potential base addresses. This is, of course, error prone and time consuming.

Locating the base address of a firmware image opens the door for a wide variety of more in-depth analysis techniques, so it is imperitive that a robust and wide spread solution is discovered. Coppola\cite{cloudscale2013} proposes a method, basefind.py, that we believe has much promise, and could one day we generalized to support images across a wide range of architectures. Currently, Coppola has used it to succesfully locate the base address of one image, so work will now turn to evaluating this technique on other images and other architures.

\section{Related Work}
Firmware entry point analysis can be considered one of the many steps in the overall study of embedded systems. As more and more objects are entering the realm of IOT and incorporate embedded systems of their own, the discussion of firmware analysis is already growing to include a wide variety of new topics. 

Meier et al\cite{fitnesstrackers2016}, Coppola\cite{cloudscale2013}, and Zaddach and Costello\cite{securityfirmwarereverse2013} touch upon the general idea of manually analyzing disassembled firmware images, mainly to extract information from headers and also for use in emulation. Manual analysis is, however, time consuming, considering the amount of information one needs to gather before they may begin to inspect actual code (which will be done with a tool such as IDA Pro). 

Because of this, many tools have been developed to automate or at least assist in much of the analysis. Zaddach et al\cite{avatar} and Costin et al\cite{dynamicanalysisatscale2015} take the dynamic analysis approach, and run a given firmware image within an emulator. Costin et al\cite{dynamicanalysisatscale2015} is of particular interest because its emulation process includes a partial emulation of the underlying hardware, meaning of course that only firmware for known hardware devices can be tested.

This lack of environmental knowledge (and often physical hardware) prompts many static approaches, such as Shoshitaishvili et al\cite{firmalice2015}, which builds off of techniques in Kruegel et al\cite{staticdisassembly2002} to reverse engineer firmware when only a binary-blob is present. This brand of analysis is especially useful, considering firmware entry point detection is usually a step in the process. 

Similar efforts and challenges in static analysis are seen in Costin et al\cite{analysisofembeddedfirmware2014}, but on a much larger scale. Tens of thousands of images weâ€™re unpacked, requiring the analysis to be general enough for a large range of binaries. The results were compared to the popular firmware analysis tool, Binwalk\cite{binwalk}, which is often used in manual static analysis. Heffner\cite{binwalk} uses known patterns to locate structures within executables, and can be particularly useful for locating firmware headers.

Heffner\cite{wrt120N2014} and Viehbock\cite{braindump2011} show examples of static analysis on firmware using Heffner\cite{binwalk} as well as other useful techniques for reverse engineering embedded systems.

Other techniques have been developed to target specific device vulnerabilities, rather than overarching analyses of firmware images. Meier\cite{fitnesstrackers2016} and Cui et al\cite{firmwaremodsattack} focus on the exploitation of firmware updates to deliver malicious code (to fitness trackers and HP printers, respectively), and note a general lacking in the current state of firmware security. Similarly, FIE\cite{fie2013} is a tool developed to find bugs in the MSP430 family of micro controllers, building off of Cadar et al\cite{klee2008} for the purposes of conducting symbolic execution. While these analyses are limited in scope, they all shed light into interesting ways of inspecting firmware that can potentially be applied to a greater and more general range of devices. 

\section{Background}
OPTIONAL

\section{Design}

\section{Implementation}

\section{Evaluation}

\section{Discussion}
OPTIONAL
Place to explain if there is something weird about the result

\section{Limitations and Future Work}

\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{research}
\end{document}