\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{epsfig,endnotes,natbib}
\begin{document}

\title{\Large \bf Firmware Entry Points in Memory}
\author{
    {\rm Mahmoud Dolah}\\
    NYU Tandon School of Engineering
    \and
    {\rm Rafael De Los Santos}\\
    NYU Tandon School of Engineering
}

\date{}

\maketitle

\thispagestyle{empty}

\subsection*{Abstract}
Finding the entry points of firmware in memory is a problem that is featured prominently in many embedded systems. It is hard to find out because the method for it is not standardized and, since firmware works under the operating system, it does not follow the same rules that the OS uses. In this paper, we present a static analysis approach for automating the process of finding the entry point of firmware in memory with a script called Basefind.py, which was created by Michael Coppola. We test his script against openwrt binaries compiled to MIPS. By analyzing the contents of a firmware binary, particularly the amount of strings that are referenced by each pointer, we can create a list of potential base addresses.  
TO DO: EVALUATION AND TAKEAWAY

\section{Introduction}
Unlike other areas of modern consumer computing, embeded systems suffer from a glaring lack of standardization. When shopping for a home pc or smartphone, for example, one could be relatively confident that most of the devices presented to them share similarities in hardware or software implementation. An analysis of any of these devices may provide the consumer with an intuition about other devices in their category. The same, unfortunatly, could not be said for a device running an embeded system or system on a chip. Because of the variety in software and especially hardware implementation techniques, an analysis of, say, a router, fitness tracker, or bluetooth dongle, will often yield little useful information for any kind of large scale study. Whats worse, the analysis techniques and tools used for any particular embeded system often cannot be carried over to another, forcing the analyst to redo, usually from scratch, their work.

When conducting an analysis of a firmware image, we often start with trying to find the base address of the binary. Because no tools (or even methods) exist that apply to a wide range of firmware binaries, and considering it is quite possible that information on the architecture of the device is sparse or poorly documented, researches often have to rely on manual, static analysis. This, in part, also has to do with the fact that quite often the source hardware isn't available, so reliable dynamic analysis is usually out of the question. When attempting to do an analysis on a large body of firmware binaries, like for instance the Open Wrt library, it would almost be impossible to expect a researcher to obtain, and run some kind of dynamic analysis on, every single phsysical device.

What follows includes disassembly in some commercial tool (perhaps IDA Pro), followed by a manual analysis of the disasembly for potential base addresses. This is, of course, error prone and time consuming.

Locating the base address of a firmware image opens the door for a wide variety of more in-depth analysis techniques, so it is imperitive that a robust and wide spread solution is discovered. Coppola\cite{cloudscale2013} proposes a method, basefind.py, that we believe has much promise, and could one day we generalized to support images across a wide range of architectures. Currently, Coppola has used it to succesfully locate the base address of one image, so work will now turn to evaluating this technique on other images and other architures.

\section{Related Work}
Firmware entry point analysis can be considered one of the many steps in the overall study of embedded systems. As more and more objects are entering the realm of IOT and incorporate embedded systems of their own, the discussion of firmware analysis is already growing to include a wide variety of new topics. 

Meier et al\cite{fitnesstrackers2016}, Coppola\cite{cloudscale2013}, and Zaddach and Costello\cite{securityfirmwarereverse2013} touch upon the general idea of manually analyzing disassembled firmware images, mainly to extract information from headers and also for use in emulation. Manual analysis is, however, time consuming, considering the amount of information one needs to gather before they may begin to inspect actual code (which will be done with a tool such as IDA Pro). 

Because of this, many tools have been developed to automate or at least assist in much of the analysis. Zaddach et al\cite{avatar} and Costin et al\cite{dynamicanalysisatscale2015} take the dynamic analysis approach, and run a given firmware image within an emulator. Costin et al\cite{dynamicanalysisatscale2015} is of particular interest because its emulation process includes a partial emulation of the underlying hardware, meaning of course that only firmware for known hardware devices can be tested.

This lack of environmental knowledge (and often physical hardware) prompts many static approaches, such as Shoshitaishvili et al\cite{firmalice2015}, which builds off of techniques in Kruegel et al\cite{staticdisassembly2002} to reverse engineer firmware when only a binary-blob is present. This brand of analysis is especially useful, considering firmware entry point detection is usually a step in the process. 

Similar efforts and challenges in static analysis are seen in Costin et al\cite{analysisofembeddedfirmware2014}, but on a much larger scale. Tens of thousands of images weâ€™re unpacked, requiring the analysis to be general enough for a large range of binaries. The results were compared to the popular firmware analysis tool, Binwalk\cite{binwalk}, which is often used in manual static analysis. Heffner\cite{binwalk} uses known patterns to locate structures within executables, and can be particularly useful for locating firmware headers.

Heffner\cite{wrt120N2014} and Viehbock\cite{braindump2011} show examples of static analysis on firmware using Heffner\cite{binwalk} as well as other useful techniques for reverse engineering embedded systems.

Other techniques have been developed to target specific device vulnerabilities, rather than overarching analyses of firmware images. Meier\cite{fitnesstrackers2016} and Cui et al\cite{firmwaremodsattack} focus on the exploitation of firmware updates to deliver malicious code (to fitness trackers and HP printers, respectively), and note a general lacking in the current state of firmware security. Similarly, FIE\cite{fie2013} is a tool developed to find bugs in the MSP430 family of micro controllers, building off of Cadar et al\cite{klee2008} for the purposes of conducting symbolic execution. While these analyses are limited in scope, they all shed light into interesting ways of inspecting firmware that can potentially be applied to a greater and more general range of devices. 

\section{Background}
OPTIONAL

\section{Design}
Basefind.py, created by Coppola\cite{cloudscale2013}, is a relatively small python script that was successfully used to located the entry point of a firmware binary. As mentioned in Coppola's lecture, Basefind.py begins by locating all strings within a given executable. It then does another pass over the file, this time to locate every double word, which it will then consider as a potential base address. For each potential address, Basefind.py attempts to locate the number of strings referenced. The address that references the most strings is meant to be considered as the base address, but Basefind.py will output the 20 highest ranked addresses in case the first is incorrect. 

Of course, this does not remove the need for manual analysis. A person still needs to evaluate each of these base address candidates to see if there is a match, and it is possible that all 20 could be negative. Assuming there is a match, Basefind.py does however drastically reduce the amount of time an analyst needs to spend on this first step. 

\section{Implementation}
Coppola\cite{cloudscale2013} originally tested Basefind.py on an arm binary. Our analysis attempts to run the same script on other binaries to evaluate whether or not this is a useful method towards generalizing Coppola's approach. Our sample space of binaries includes Coppola's original binary and MIPS binaries from Open WRT. Specifically, some of the MIPS binaries from Open WRT were compiled in elf format, which is helpful for decompiling and checking the results of Basefind.py.

Each binary was scanned with Basefind.py. For binaries compiled to elf, the resulting base addresses were checked against a readelf decompilation. Running Basefind.py on non-elf binaries was still useful to evaluate the runtime of Basefind.py.

\section{Evaluation}

\section{Discussion}
OPTIONAL
Place to explain if there is something weird about the result

\section{Limitations and Future Work}

\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{research}
\end{document}